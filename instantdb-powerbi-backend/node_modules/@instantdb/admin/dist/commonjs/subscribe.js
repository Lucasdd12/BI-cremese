"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.subscribe = subscribe;
const eventsource_1 = require("eventsource");
const version_ts_1 = __importDefault(require("./version.js"));
const core_1 = require("@instantdb/core");
function makeAsyncIterator(subscribe, subscribeOnClose, unsubscribe, readyState) {
    let wakeup = null;
    let closed = false;
    const backlog = [];
    const handler = (data) => {
        backlog.push(data);
        if (backlog.length > 100) {
            // Remove the oldest item to prevent the backlog
            // from growing forever. This is okay for live queries,
            // but we need some other machanism if we use this for
            // event-based subscriptions.
            backlog.shift();
        }
        if (wakeup) {
            wakeup();
            wakeup = null;
        }
    };
    subscribe(handler);
    const done = () => {
        unsubscribe(handler);
        return Promise.resolve({ done: true, value: undefined });
    };
    const onClose = () => {
        closed = true;
        if (wakeup) {
            wakeup();
        }
        done();
    };
    subscribeOnClose(onClose);
    const next = async () => {
        while (true) {
            if (readyState() === 'closed' || closed) {
                return done();
            }
            const nextValue = backlog.shift();
            if (nextValue) {
                return { value: nextValue, done: false };
            }
            const p = new Promise((resolve) => {
                wakeup = resolve;
            });
            await p;
        }
    };
    return {
        next,
        return: done,
        throw(error) {
            unsubscribe(handler);
            return Promise.reject(error);
        },
        [Symbol.asyncIterator]() {
            return this;
        },
    };
}
function esReadyState(es) {
    switch (es.readyState) {
        case es.CLOSED: {
            return 'closed';
        }
        case es.CONNECTING: {
            return 'connecting';
        }
        case es.OPEN: {
            return 'open';
        }
        default:
            return 'connecting';
    }
}
function multiReadFetchResponse(r) {
    let p = null;
    return {
        ...r,
        text() {
            if (!p) {
                p = r.text();
            }
            return p;
        },
        json() {
            if (!p) {
                p = r.text();
            }
            return p.then((x) => JSON.parse(x));
        },
    };
}
function formatPageInfo(pageInfo) {
    if (!pageInfo) {
        return undefined;
    }
    const res = {};
    for (const [k, v] of Object.entries(pageInfo)) {
        res[k] = {
            startCursor: v['start-cursor'],
            endCursor: v['end-cursor'],
            hasNextPage: v['has-next-page?'],
            hasPreviousPage: v['has-previous-page?'],
        };
    }
    return res;
}
function subscribe(query, cb, opts) {
    let fetchErrorResponse;
    let closed = false;
    // Stable id that will stay the same across reconnects,
    // used for debugging
    const localConnectionId = (0, core_1.id)();
    const es = new eventsource_1.EventSource(`${opts.apiURI}/admin/subscribe-query?local_connection_id=${localConnectionId}`, {
        fetch(input, init) {
            fetchErrorResponse = null;
            return fetch(input, {
                ...init,
                method: 'POST',
                headers: opts.headers,
                body: JSON.stringify({
                    query: query,
                    'inference?': opts.inference,
                    versions: {
                        '@instantdb/admin': version_ts_1.default,
                        '@instantdb/core': core_1.version,
                    },
                }),
            }).then((r) => {
                if (!r.ok) {
                    fetchErrorResponse = multiReadFetchResponse(r);
                }
                return r;
            });
        },
    });
    const subscribers = [];
    const onCloseSubscribers = [];
    const subscribe = (cb) => {
        subscribers.push(cb);
    };
    const unsubscribe = (cb) => {
        subscribers.splice(subscribers.indexOf(cb), 1);
    };
    const subscribeOnClose = (cb) => {
        onCloseSubscribers.push(cb);
    };
    if (cb) {
        subscribe(cb);
    }
    let sessionParams = null;
    function deliver(result) {
        if (closed) {
            return;
        }
        for (const sub of subscribers) {
            try {
                sub(result);
            }
            catch (e) {
                console.error('Error in subscribeQuery callback', e);
            }
        }
    }
    function handleMessage(msg) {
        switch (msg.op) {
            case 'sse-init': {
                const machineId = msg['machine-id'];
                const sessionId = msg['session-id'];
                sessionParams = { machineId, sessionId };
                break;
            }
            case 'add-query-ok': {
                deliver({
                    type: 'ok',
                    data: msg.result,
                    pageInfo: formatPageInfo(msg['result-meta']?.['page-info']),
                    sessionInfo: sessionParams,
                });
                break;
            }
            case 'refresh-ok': {
                if (msg.computations.length) {
                    deliver({
                        type: 'ok',
                        data: msg.computations[0]['instaql-result'],
                        pageInfo: formatPageInfo(msg.computations[0]['result-meta']?.['page-info']),
                        sessionInfo: sessionParams,
                    });
                }
                break;
            }
            case 'error': {
                deliver({
                    type: 'error',
                    error: new core_1.InstantAPIError({ body: msg, status: msg.status }),
                    get readyState() {
                        return esReadyState(es);
                    },
                    get isClosed() {
                        return esReadyState(es) === 'closed';
                    },
                    sessionInfo: sessionParams,
                });
                break;
            }
        }
    }
    es.onerror = (e) => {
        if (fetchErrorResponse) {
            fetchErrorResponse.text().then((t) => {
                let body = { type: undefined, message: t };
                try {
                    body = JSON.parse(t);
                }
                catch (_e) { }
                deliver({
                    type: 'error',
                    error: new core_1.InstantAPIError({
                        status: fetchErrorResponse.status,
                        body,
                    }),
                    get readyState() {
                        return esReadyState(es);
                    },
                    get isClosed() {
                        return esReadyState(es) === 'closed';
                    },
                    sessionInfo: sessionParams,
                });
            });
        }
        else {
            const deliverError = () => {
                deliver({
                    type: 'error',
                    error: new core_1.InstantAPIError({
                        status: e.code || 500,
                        body: {
                            type: undefined,
                            message: e.message || 'Unknown error in subscribe query.',
                        },
                    }),
                    get readyState() {
                        return esReadyState(es);
                    },
                    get isClosed() {
                        return esReadyState(es) === 'closed';
                    },
                    sessionInfo: sessionParams,
                });
            };
            if (es.readyState === eventsource_1.EventSource.CLOSED) {
                deliverError();
                return;
            }
            setTimeout(() => {
                if (es.readyState !== eventsource_1.EventSource.OPEN) {
                    deliverError();
                }
            }, 5000);
        }
    };
    es.onmessage = (e) => {
        handleMessage(JSON.parse(e.data));
    };
    const close = () => {
        closed = true;
        for (const sub of onCloseSubscribers) {
            try {
                sub();
            }
            catch (e) {
                console.error('Error in onClose callback', e);
            }
        }
        es.close();
    };
    return {
        close: close,
        [Symbol.iterator]: () => {
            throw new Error('subscribeQuery does not support synchronous iteration. Use `for await` instead.');
        },
        get sessionInfo() {
            return sessionParams;
        },
        get readyState() {
            return esReadyState(es);
        },
        get isClosed() {
            return esReadyState(es) === 'closed';
        },
        [Symbol.asyncIterator]: makeAsyncIterator.bind(this, subscribe, subscribeOnClose, unsubscribe, () => 1),
    };
}
//# sourceMappingURL=subscribe.js.map